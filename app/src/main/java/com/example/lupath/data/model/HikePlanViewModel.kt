package com.example.lupath.data.model

import android.widget.Toast
import androidx.compose.runtime.R
import androidx.compose.runtime.mutableStateListOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lupath.data.database.dao.HikePlanDao
import com.example.lupath.data.database.dao.HikePlanWithMountainName
import com.example.lupath.data.database.dao.MountainDao
import com.example.lupath.data.database.entity.HikePlanEntity
import dagger.hilt.android.lifecycle.HiltViewModel
import jakarta.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.mapLatest
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.util.UUID

@HiltViewModel
class HikePlanViewModel @Inject constructor(
    private val hikePlanDao: HikePlanDao, // Inject your DAOs (e.g., via Hilt)
    private val mountainDao: MountainDao   // Or a Repository that uses these DAOs
) : ViewModel() {

    private val _hikePlans = MutableStateFlow<List<HikePlan>>(
        (emptyList())
    )

    // This StateFlow directly observes the database via the DAO
    @OptIn(ExperimentalCoroutinesApi::class)
    val hikePlans: StateFlow<List<HikePlan>> =
        hikePlanDao.getAllHikePlansWithMountainName() // DAO returns Flow<List<HikePlanWithMountainName>>
            .mapLatest { listPlanWithMountainNameFromDb -> // Use mapLatest to cancel previous mapping if new data comes fast
                // Asynchronously fetch difficulty for each plan to avoid blocking map
                listPlanWithMountainNameFromDb.map { planWithMountain ->
                    // Fetch mountain entity to get its difficulty
                    // Assuming MountainEntity has difficultyText
                    val mountainEntity = mountainDao.getMountainByIdNonFlow(planWithMountain.hikePlan.mountainOwnerId ?: "")
                    val difficultyText = mountainEntity?.difficultyText ?: "N/A"

                    HikePlan( // Convert to your UI Model
                        id = planWithMountain.hikePlan.hikePlanId,
                        mountainId = planWithMountain.hikePlan.mountainOwnerId ?: "",
                        mountainName = planWithMountain.mountainName ?: "Unknown Mountain",
                        date = planWithMountain.hikePlan.date,
                        difficulty = difficultyText,
                        imageResourceName = planWithMountain.mountainPictureReference,
                        notes = planWithMountain.hikePlan.notes
                    )
                }
            }
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = emptyList() // Start with an empty list until DB loads
            )

    // Called from DatePickerScreen when a user confirms a date for a mountain
    fun addHikePlanFromPicker(mountainIdFromPicker: String, selectedDate: LocalDate, notes: String?) {
        viewModelScope.launch(Dispatchers.IO) { // Use Dispatchers.IO for database operations
            val newHikePlanEntity = HikePlanEntity(
                // hikePlanId can be auto-generated by Room if you set autoGenerate = true
                // or use UUID.randomUUID().toString() if you manage it
                hikePlanId = UUID.randomUUID().toString(),
                mountainOwnerId = mountainIdFromPicker,
                date = selectedDate,
                notes = notes
            )
            hikePlanDao.insertHikePlan(newHikePlanEntity)
            // The 'hikePlans' StateFlow will automatically update because it observes the database.
        }
    }

    fun removeHikePlan(hikePlanUiModel: HikePlan) {
        viewModelScope.launch(Dispatchers.IO) {
            // Create an entity with the same ID to delete from the database
            val entityToDelete = HikePlanEntity(
                hikePlanId = hikePlanUiModel.id,
                mountainOwnerId = hikePlanUiModel.mountainId,
                date = hikePlanUiModel.date,
                notes = hikePlanUiModel.notes
            )
            hikePlanDao.deleteHikePlan(entityToDelete)
        }
    }

    fun updateHikePlanDate(hikePlanId: String, mountainId: String, newDate: LocalDate, newNotes: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            // To update, you typically need the full entity or at least its ID.
            // If you only want to update the date, you could fetch the existing entity first,
            // modify its date, and then pass it to the update DAO method.
            // Or, if your DAO's @Update method can handle partial updates based on ID (less common for simple @Update),
            // or if you create a specific DAO method for updating just the date.
            // For simplicity with a standard @Update, we'll assume we need to provide the entity.
            // We need mountainOwnerId for the entity constructor.
            val updatedHikePlanEntity = HikePlanEntity(
                hikePlanId = hikePlanId, // Keep the original ID
                mountainOwnerId = mountainId, // Keep the original mountainId
                date = newDate,
                notes = newNotes,// Set the new date
            )
            hikePlanDao.updateHikePlan(updatedHikePlanEntity)
            // The 'hikePlans' StateFlow will automatically update due to database observation.
        }
    }



    // --- Methods to modify the state ---

//    fun addHikePlan(hikePlan: HikePlan) {
//        // Use the 'update' extension function for safe concurrent updates
//        _hikePlans.update { currentList ->
//            // Create a new list by adding the new plan
//            currentList + hikePlan // '+' operator creates a new list
//        }
//        // In a real app, you'd also save this change to a database/repository
//    }


    // Optional: If you need to load data asynchronously
    init {
        // loadInitialPlans() // You could call a loading function here if needed
    }

//    fun createPlanFromSelectedMountain(selectedMountain: Mountain, selectedDate: LocalDate) {
//        addHikePlan(selectedMountain, selectedDate)
//    }
//
//    private fun loadInitialPlans() {
//        viewModelScope.launch {
//            // Simulate loading from a repository
//            // val initialPlans = repository.getHikePlans()
//            // _hikePlans.value = initialPlans
//        }
//    }
}

