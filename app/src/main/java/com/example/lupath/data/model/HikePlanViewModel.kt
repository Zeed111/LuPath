package com.example.lupath.data.model

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lupath.data.database.dao.HikePlanDao
import com.example.lupath.data.database.dao.MountainDao
import com.example.lupath.data.database.entity.HikePlanEntity
import dagger.hilt.android.lifecycle.HiltViewModel
import jakarta.inject.Inject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.mapLatest
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.util.UUID

@HiltViewModel
class HikePlanViewModel @Inject constructor(
    private val hikePlanDao: HikePlanDao,
    private val mountainDao: MountainDao
) : ViewModel() {

    // This StateFlow directly observes the database via the DAO
    @OptIn(ExperimentalCoroutinesApi::class)
    val hikePlans: StateFlow<List<HikePlan>> =
        hikePlanDao.getAllHikePlansWithMountainName() // DAO returns Flow<List<HikePlanWithMountainName>>
            .mapLatest { listPlanWithMountainNameFromDb -> // Use mapLatest to cancel previous mapping if new data comes fast
                // Asynchronously fetch difficulty for each plan to avoid blocking map
                listPlanWithMountainNameFromDb.map { planWithMountain ->

                    val mountainEntity = mountainDao.getMountainByIdNonFlow(planWithMountain.hikePlan.mountainOwnerId ?: "")
                    val difficultyText = mountainEntity?.difficultyText ?: "N/A"

                    HikePlan(
                        id = planWithMountain.hikePlan.hikePlanId,
                        mountainId = planWithMountain.hikePlan.mountainOwnerId ?: "",
                        mountainName = planWithMountain.mountainName ?: "Unknown Mountain",
                        date = planWithMountain.hikePlan.date,
                        difficulty = difficultyText,
                        imageResourceName = planWithMountain.mountainPictureReference,
                        notes = planWithMountain.hikePlan.notes
                    )
                }
            }
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5000),
                initialValue = emptyList() // Start with an empty list until DB loads
            )

    // Called from DatePickerScreen when a user confirms a date for a mountain
    fun addHikePlanFromPicker(mountainIdFromPicker: String, selectedDate: LocalDate, notes: String?) {
        viewModelScope.launch(Dispatchers.IO) { // Use Dispatchers.IO for database operations
            val newHikePlanEntity = HikePlanEntity(
                // hikePlanId can be auto-generated by Room if set autoGenerate = true
                // or UUID.randomUUID().toString() if manage it
                hikePlanId = UUID.randomUUID().toString(),
                mountainOwnerId = mountainIdFromPicker,
                date = selectedDate,
                notes = notes
            )
            hikePlanDao.insertHikePlan(newHikePlanEntity)
        }
    }

    fun removeHikePlan(hikePlanUiModel: HikePlan) {
        viewModelScope.launch(Dispatchers.IO) {
            // Create an entity with the same ID to delete from the database
            val entityToDelete = HikePlanEntity(
                hikePlanId = hikePlanUiModel.id,
                mountainOwnerId = hikePlanUiModel.mountainId,
                date = hikePlanUiModel.date,
                notes = hikePlanUiModel.notes
            )
            hikePlanDao.deleteHikePlan(entityToDelete)
        }
    }

    fun updateHikePlanDate(hikePlanId: String, mountainId: String, newDate: LocalDate, newNotes: String?) {
        viewModelScope.launch(Dispatchers.IO) {

            val updatedHikePlanEntity = HikePlanEntity(
                hikePlanId = hikePlanId,
                mountainOwnerId = mountainId,
                date = newDate,
                notes = newNotes,
            )
            hikePlanDao.updateHikePlan(updatedHikePlanEntity)
        }
    }
}